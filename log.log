1. std::function<bool(Key, Key)> compare 不能随便用应该，在 function 里面估计有一个同名的东西；

2. typename 到底什么时候需要用？ typename BTREE_INSTANCE:: node_type

3. Btree.h 文件里的头文件包含的合理吗？会不会导致包含这个文件的文件产生一些不好的影响？

4. 为什么在类定义内部声明函数的时候，貌似不用加一些类型名，像在类的实现文件里一样。

 可能当时说的是这个：
 > BTREE_TEMPLATE_DECLARATION
shared_ptr<typename BTREE_INSTANCE::node_instance_type> // need typename
BTREE_INSTANCE::check_out(const Key key)
{
    shared_ptr<node_instance_type> current_node = this->root_; // OK

5. 是否减少 auto 的使用

6. BTREE_INSTANCE::node_instance_type 为什么在头文件的实现文件里还需要用 typename

7. 使用堆上的内存，至少是为了所有的变量能和用户层的变量能是一样的生存周期。程序使用各个函数分割不同的任务，但由于栈上的内存对外部的变量来说具有临时性，即可以说是不存在的。那函数如何创建函数外的变量，以使这种内存得以共享、持存。————使用堆上的内存。
   但对于最外层的用户来说，使用堆上的内存是没有必要的，因为本身自己的使用一般就是在这个函数内部，比如 main 函数内部

8. node_instance_type 这个 type 声明成 private ，Btree.h 实现文件依然可以使用。莫非编译器通过某种识别，识别出这是个某个实现函数的定义？然后给予他相应的不同待遇。因为编译器本身大概是不能通过 Btree.cpp 这个文件名来给予他不同待遇。

9. std::shared_ptr<node_instance_type> root_ = std::make_shared<node_instance_type>(leaf); 这里这么使用，是为了一致性，因为 root_ 本身也会指向一些 node ，如果这里直接使用 node_instance_type root_ ，那这里就与后面的结点不同了。

10. const list<int> a{1, 2, 3, 4,};


    for (int& e : a) {
        e = 1;
    }
    // or:
    list<const int> a{1, 2, 3, 4,};


    for (int& e : a) {
        e = 1;
    }

    这两种都会报错。我猜 initializer_list 也是一样的。所以，关于这种参数的 const 化不用加太多 const 。当然像 const initializer_list<pair<const Key, const Value>> pair_list 这种，我不是很确定，因为里面又包了一个模板。

11. private: using a = int; 这个 type 是否受 private 而有范围限制？

12. 头文件里的标准库类型尽量不要用缩写，这样可以帮助查看。

13. 为了把 compare 交给用户自己实现，所以 Btree 自己不使用 < 或 >

14. (*current_node)[0] 对不对？或者 current_node[0] 应该不行吧。

15. for (auto && ele : *current_node) { maybe not correct

16. 0 is ok, other is bad.

17. 类定义遵循先公共，后私有的规则。

18. C++里类定义的声明顺序有关吗？我记得 C++ Primer 刚开始的部分有相关的内容

19. 在Btree 的模板里加入了Compare 类型参数，但是我不是很确定要加这个参数，因为构造函数里还是需要传这个参数，但是Compare 的类型不是由自己控制了。

20. 对函数注释的文字尽量使用///，需要看到的注释使用//

21. 禁止使用 > 或 < 在模板的 Btree 中的比较 Key 大小的地方

22. B+ 树里不允许相同的 key，不会执行检查，执行后来覆盖原则

23. 如果 add 最终会导致树的升层，那 remove 可否同理导致降层？

24. 类的 public 方法不要涉及更底层的细节，比如 Node 的 public 方法不要返回 Ele 相关的东西

25. 记得搜索 detail ，这些注释的是涉及到“觉得有点不应该涉及到细节”的地方

26. 当 <= 时，return true。——compare 函数

27. 是否要给所有没改变 this 函数加上 const？

28. 在库的内部，许多事情需要调用者自己保证，比如数量不越界

29. 左值和右值的界线是不是可以使用函数模糊掉
void
fun(int& b)
{
    b += 1;
    cout << b << endl;
}

void
f1(int&& b)
{
    fun(b);
}

int main()
{
    f1(2);

    return 0;
}

30. C++ 还可以这样重载运算符 operator bool() 等

31. 一些 unsigned 的地方要不要换成对应的 size_t

32. static method call like this: BTREE_INSTANCE::set_father

33. 利用 shared_ptr 或包一个 shared_ptr，这样就知道哪些地方引用了 Node，这样 Node 有变化的时候，就可以去修改相关的地方。

34. 写每一个函数的时候，看一看上下引用的函数的需求。

35. 尽量不要越层暴露细节，比如对于 Btree 不要暴露 Elements 的细节，这样会增加复杂度。

36. Btree 不是线程安全的，因为有些东西依赖了上一步，比如 weak_ptr 往往依赖了上一步的查找，这样就不用验证存在。

37. 不完全确定是否要这样自我规定：数据成员不用加 this 调用，成员函数需要。因为我怕调用有些可能不是成员的函数

38. 右值引用的实际过程

39. // all method in this level,
// when call lower level function, must ensure the Key exist

40. adjust 中需要确保没有 key_num_ 为0的结点

41. 为什么要有工厂模式？

42. Node 里有些是通过成员变量是通过构造函数列表初始化的，有些是类初始值，但是是依赖列表初始化的量，这样会有问题吗？
