远程函数调用程序设计-服务器端
----

1. 程序运行过程角度

* Init

  采用各模块在一个 init 链表里面注册自己的 init 过程。init 本身采用多线程加载的运行方式。程序开始运行后，main 里调用 init 的运行函数来运行加载过程。由于 init 里使用到多线程，而多线程来自线程池，所以线程池这个结构的 init 要先于 init 过程运行，或者线程池采用触发加载，并不特意需要去 init（，那线程池要怎么结束呢）。


* Running

  之前的设计方案采用的是多个事件队列的方式，包括请求队列、结果队列，这些都是线程间共享的数据结构，共享且又都会往里面写东西，那就需要加锁。目前认为加锁会降低处理的效率。所以尽量去掉了一些加锁的地方。

  目前程序运行的流程是这样：

  1. 一个线程不断的从监听的端口那里取来请求，交给线程池中安排一个 Item 来处理接下来函数调用的流程（这个流程是监听的线程告诉线程池的）。这里线程池自己需要配备一个事件队列，来存储这个线程交给自己的任务。

  > 这么看，事件队列还是回来了，只不过从请求队列转变为一个功能比较扩大化的事件队列。

  2. 线程池安排一个 item 来执行监听线程安排的任务。运行的过程中会写日志，经过包装后的日志器含有一个待写日志队列（比如定数量往磁盘写入，但程序退出时保证清空写入以清空队列）。期间也会读取函数库产生调用操作，经过包装后的函数库，各读取操作之间不互相阻塞，写入操作阻塞读取操作和其他写入操作。

  3. 此 item 所运行的过程中包含将函数调用结果压入一个响应发送队列中。响应发送队列的压入操作会触发一个线程池中的 item 执行发送操作。发送操作将发送完当前队列中所有的待发送响应。发送过程中，相应发送队列可以在另外一部分单独存在，这样实际发送过程就不会阻塞压入队列的操作。至多只有一个 item 对将要发送的队列执行操作，多个 item 执行操作容易造成争抢，但是在明确好已有的队列中的项谁发送的前提下，可以使用多个 item 发送。执行完毕后，item 回归线程池管理。

     > 此处的包装类似《SICP》第三章提到的串行化访问

  UI 线程所进行的操作可以被包含在上面的流程中。

2. 程序模块角度

* 函数库
  * 编译增加的函数的时候需要添加一些代码（此仅为需要注意的点，非函数库全部内容）
  * 调用的时候到底是怎么调的，是手工加载调用还是直接像 CSAPP 上那样读取 dll 就行
* JSON 序列化和反序列化
* 一次远程函数调用的流程
* 线程池（或许和协程有关）
* 日志
* TUI (Terminal User Interface)
* UI 中可以运行的命令的逻辑
* 串行化包装
* 自动化打包发布
